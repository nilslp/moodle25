<?php

/* 
 * This file is part of Totara LMS
 *
 * Copyright (C) 2010, 2011 Totara Learning Solutions LTD
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @author Simon Coggins <simon.coggins@totaralms.com>
 * @package totara
 * @subpackage utils
 */

/*
 * This file contains general purpose utility functions
 */


/**
 * Check if a specified language string already exists
 *
 * The arguments are the same as those given to get_string() with the
 * exception of $a which is not required
 *
 * @param string $identifier The key identifier for the language string
 * @param string $module Module where the key identifier is stored
 * @param array $extralocations Array of strings with other locations
 *                              to check for the string
 *
 * @return boolean True if string exists
 */
function check_string($identifier, $module='', $extralocations=null) {
    $result = @get_string($identifier, $module, null, $extralocations);

    if($result == '[[' . $identifier . ']]') {
        return false;
    } else {
        return true;
    }
}


/**
 * gets a list of all courses and categories organised into a tree structure
 * @return hierarchy_tree  
 */
function local_lp_getcoursetree($catexclude = null, $courseexclude = null) {
    global $DB,$CFG;
    
    if (!file_exists($CFG->dirroot.'/blocks/lp_hierarchy')) {
        return null;
    }
    
    require_once($CFG->dirroot.'/blocks/lp_hierarchy/lib.php');
    
    $tree = new hierarchy_tree();
    
    if (!isset($courseexclude)){
        $courseexclude = array();
    }
    
    // ignore site
    $courseexclude []= SITEID;
    
    $categories = get_categories('none', 'cc.depth ASC');
    foreach ($categories as $cat){
        if (!empty($catexclude) && in_array($cat->id, $catexclude)) {
            continue;
        }
        $context = $DB->get_field('context', 'id', array('instanceid'=>$cat->id,'contextlevel'=>CONTEXT_COURSECAT));
        $node = $tree->insert_branch_node($cat->parent, $cat->id, $cat->name, array('visible'=>$cat->visible));
        $node->context = $context;
    }
    
    $courses = get_courses('all', 'c.category', 'c.id,c.fullname AS name,c.id,c.category,c.visible');
    foreach ($courses as $course){
        if (!empty($courseexclude) && in_array($course->id, $courseexclude)) {
            continue;
        }
        $context = $DB->get_field('context', 'id', array('instanceid'=>$course->id,'contextlevel'=>CONTEXT_COURSE));
        $course->context = $context;
        $tree->insert_leaf_node($course->category, $course->id, $course);
    }
    return $tree;
}

/**
 * Utility function - takes a string representation of an org hierarchy generated
 * by the YUI TreeView control and creates the unique valued list of ids
 * 
 * @param string $hierids - query var generated by the TreeView control
 * @return array 
 */
function local_lp_parse_hierarchy_param($hierids){
    $ids = array();
    if (empty($hierids)){
        return $ids;
    }
    
    $hierids = explode(',',$hierids);
    foreach ($hierids as $hid){
        $hid = explode('_',$hid);
        if (!empty($hid)){
            $ids[$hid[count($hid)-1]] = 1;
        }
    }
    
    return array_keys($ids);
}

/**
 * Utility function - takes a string representation of a category/course hierarchy
 * generated by the YUI TreeView control and returns an array with indexed course
 * and category lists. 
 *  
 * @param string $courseids - query var generated by the TreeView control
 * @return array 
 */
function local_lp_parse_courselist_param($courseids){
    $ids = array();
    if (empty($courseids)){
        return $ids;
    }
    
    $courseids = explode(',',$courseids);
    foreach ($courseids as $cid){
        $cid = explode('_',$cid);
        if (empty($cid)){
            continue;
        }
        
        $pointer = &$ids;
        while ($c = array_shift($cid)){
            if (!isset($pointer[$c])){
                $pointer[$c] = array();
            }
            $pointer = &$pointer[$c];
        }
    }
    
    $ret = array();
    local_lp_course_or_category($ids, $ret['course'], $ret['category']);
    
    $ret['course'] = array_unique($ret['course']);
    $ret['category'] = array_unique($ret['category']);
    
    return $ret;
}

/**
 * Utility function - used by local_lp_parse_courselist_param
 * recurses through the multi-dimensional array produced by that
 * function and decides which entry is a course and which a category.
 * 
 * @param array $array
 * @param ref array $courses
 * @param ref array $categories 
 */
function local_lp_course_or_category( $array, &$courses, &$categories, $type='' ){
    
    if (!isset($courses)){
        $courses = array();
    }
    
    if (!isset($categories)){
        $categories = array();
    }
    
    foreach ($array as $key=>$val){
        if (!is_numeric($key)){
            $type = $key;
        } else {        
            if (empty($val)){
                if ('course' == $type){
                    $courses [] = $key;
                } else {
                    $categories []= $key;
                }
                continue;
            }
            $categories []= $key;
        }
        local_lp_course_or_category($val, $courses, $categories, $type);
    }
}

/**
 * Utility function returns the children, grandchildren etc of the passed category
 * @global moodle_database $DB
 * @param int $category
 * @return array list of discovered children 
 */
function local_lp_get_related_categories($category){
    global $DB;        
    $ret = array();
    $children = $DB->override_get_records_sql("SELECT id FROM {course_categories} WHERE parent=$category");
    if (!empty($children)){
        foreach ($children  as $child){
            if ($child->id == $category){
                // prevent infinite recursion on messed up category trees!
                continue;
            }
            $ret []= $child->id;
            $ret = array_merge($ret, local_lp_get_related_categories($child->id));
        }
    }

    return array_unique($ret);
}

/**
 * utility function - builds an array that maps
 * the old dir/dep/subdep structure to the new
 * hierarchy structure for convenience
 * 
 * @global moodle_database $DB
 * @return array
 */
function local_lp_build_hierarchy_map() {
    global $DB;
    
    $map = array(
        'directorate'   => array(),
        'department'    => array(),
        'subdepartment' => array(),
        'orphan' => array()             // probably won't happen ...
    );
    
    // get maps from db, leaving out new or unmappable org levels
    $records = $DB->get_records_sql(
            "SELECT 
                h.id,
                CASE d.level
                    WHEN 1 THEN 'directorate'
                    WHEN 2 THEN 'department'
                    WHEN 3 THEN 'subdepartment'
                    ELSE 'orphan'
                END AS levelid,
                h.oldid 
                FROM 
                    {lp_hierarchy} h
                    JOIN 
                        {lp_hierarchy_depth} d
                    ON d.id=h.depthid
                WHERE h.oldid IS NOT NULL
                ORDER BY d.level ASC;"
            );
    
    foreach ($records as $rec) {
        $map[$rec->levelid][$rec->oldid] = $rec->id;
    }
    
    return $map;    
}

/** 
 * Download an excel file from arbitrary query
 * 
 */
function local_learningpool_download_xls($shortname, $fields, $sql, $count, $file=null) {
    global $CFG, $DB;

    require_once("$CFG->libdir/excellib.class.php");

    // for long reports, keep sessions and php alive
    set_time_limit(300);

    $datetime = date('d-M-Y');
    $filename = clean_filename($shortname.'_' . $datetime . '.xls');
    $blocksize = 1000;

    if(!$file){
        header("Content-Type: application/vnd.ms-excel\n");
        header("Content-Disposition: attachment; filename=$filename");
        header("Expires: 0");
        header("Cache-Control: must-revalidate,post-check=0,pre-check=0");
        header("Pragma: public");

        $workbook = new MoodleExcelWorkbook('-');
        $workbook->send($filename);
    }
    else {
        $workbook = new MoodleExcelWorkbook($file);
    }

    $worksheet = array();

    $worksheet[0] =& $workbook->add_worksheet('');
    $row = 0;
    $col = 0;
    $dateformat =& $workbook->add_format();
    $dateformat->set_num_format('dd mmm yyyy');
    $datetimeformat =& $workbook->add_format();
    $datetimeformat->set_num_format('dd mmm yyyy h:mm');
    $system_timezone = date_default_timezone_get();
    date_default_timezone_set('UTC');
    date_default_timezone_set($system_timezone);  

    foreach ($fields as $field) {
        if (isset($field['heading'])) {
            $worksheet[0]->write($row, $col, strip_tags($field['heading']));
        }
        $col++;
    }
    $row++;
    
    $numfields = count($fields);
    
    // break the data into blocks as single array gets too big
    for($k=0;$k<=floor($count/$blocksize);$k++) {
        $start = $k*$blocksize;
        $data = $DB->get_records_sql($sql, array(), $start, $blocksize);
        foreach ($data as $datarow) {
            for ($col = 0; $col < $numfields; $col++) {
                $colname = $fields[$col]['fieldname'];                
                if (isset($datarow->$colname)) {
                    // apply any filters
                    if (isset($fields[$col]['filter'])) {
                        $datarow->$colname = $fields[$col]['filter']->filter($datarow->$colname);
                    }
                    
                    switch ($fields[$col]['format']) {
                        case 'url':
                            if (empty($datarow->$colname)) {
                                $worksheet[0]->write($row, $col, '');
                            } else {
                                // For some reason, write url produces garbage :-\
                                // $worksheet[0]->write_url($row, $col, $datarow->$colname);
                                $worksheet[0]->write_string($row, $col, $datarow->$colname);
                            }
                            break;
                        case 'date':
                            if (empty($datarow->$colname)) {
                                $worksheet[0]->write($row, $col, '');
                            } else {
                                $worksheet[0]->write_date($row, $col, $datarow->$colname, $dateformat);
                            }
                            break;
                        case 'datetime':
                            if (empty($datarow->$colname)) {
                                $worksheet[0]->write($row, $col, '');
                            } else {
                                $worksheet[0]->write_date($row, $col, $datarow->$colname, $datetimeformat);
                            }
                            break;
                        case 'string':
                            $worksheet[0]->write_string($row, $col, strip_tags(html_entity_decode($datarow->$colname, ENT_COMPAT, 'UTF-8')));   
                            break;
                        default:
                            $worksheet[0]->write($row, $col, strip_tags(html_entity_decode($datarow->$colname, ENT_COMPAT, 'UTF-8')));
                            break;
                    }
                }
            }
            $row++;
        }
    }


    $workbook->close();
    if(!$file){
        die;
    }
}

/**
 * Replicating core moodle email_to_user function to allow adding of CC. We want the email behaviour to be 
 * identical otherwise, so this seems the most straightfoward, if wasteful, method :-\  
 * 
 * @global class $CFG
 * @global type $FULLME
 * @param type $user
 * @param type $from
 * @param type $subject
 * @param type $messagetext
 * @param type $cclist
 * @param type $messagehtml
 * @param type $attachment
 * @param type $attachname
 * @param type $usetrueaddress
 * @param type $replyto
 * @param type $replytoname
 * @param type $wordwrapwidth
 * @return boolean 
 */
function local_learningpool_email_to_user($user, $from, $subject, $messagetext, $cclist=false, $messagehtml='', $attachment='', $attachname='', $usetrueaddress=true, $replyto='', $replytoname='', $wordwrapwidth=79) {
    global $CFG, $FULLME;

    if (is_array($user)) {
        $user = current($user);
    }
    
    if (empty($user) || empty($user->email)) {
        $nulluser = 'User is null or has no email';
        error_log($nulluser);
        if (CLI_SCRIPT) {
            mtrace('Error: local/learningpool/utils.php local_learningpool_email_to_user(): '.$nulluser);
        }
        return false;
    }

    if (!empty($user->deleted)) {
        // do not mail deleted users
        $userdeleted = 'User is deleted';
        error_log($userdeleted);
        if (CLI_SCRIPT) {
            mtrace('Error: local/learningpool/utils.php local_learningpool_email_to_user(): '.$userdeleted);
        }
        return false;
    }

    if (!empty($CFG->noemailever)) {
        // hidden setting for development sites, set in config.php if needed
        $noemail = 'Not sending email due to noemailever config setting';
        error_log($noemail);
        if (CLI_SCRIPT) {
            mtrace('Error: local/learningpool/utils.php local_learningpool_email_to_user(): '.$noemail);
        }
        return true;
    }

    if (!empty($CFG->divertallemailsto)) {
        $subject = "[DIVERTED {$user->email}] $subject";
        $user = clone($user);
        $user->email = $CFG->divertallemailsto;
    }

    // skip mail to suspended users
    if ((isset($user->auth) && $user->auth=='nologin') or (isset($user->suspended) && $user->suspended)) {
        return true;
    }

    if (!validate_email($user->email)) {
        // we can not send emails to invalid addresses - it might create security issue or confuse the mailer
        $invalidemail = "User $user->id (".fullname($user).") email ($user->email) is invalid! Not sending.";
        error_log($invalidemail);
        if (CLI_SCRIPT) {
            mtrace('Error: local/learningpool/utils.php local_learningpool_email_to_user(): '.$invalidemail);
        }
        return false;
    }

    if (over_bounce_threshold($user)) {
        $bouncemsg = "User $user->id (".fullname($user).") is over bounce threshold! Not sending.";
        error_log($bouncemsg);
        if (CLI_SCRIPT) {
            mtrace('Error: local/learningpool/utils.php local_learningpool_email_to_user(): '.$bouncemsg);
        }
        return false;
    }

    // If the user is a remote mnet user, parse the email text for URL to the
    // wwwroot and modify the url to direct the user's browser to login at their
    // home site (identity provider - idp) before hitting the link itself
    if (is_mnet_remote_user($user)) {
        require_once($CFG->dirroot.'/mnet/lib.php');

        $jumpurl = mnet_get_idp_jump_url($user);
        $callback = partial('mnet_sso_apply_indirection', $jumpurl);

        $messagetext = preg_replace_callback("%($CFG->wwwroot[^[:space:]]*)%",
                $callback,
                $messagetext);
        $messagehtml = preg_replace_callback("%href=[\"'`]($CFG->wwwroot[\w_:\?=#&@/;.~-]*)[\"'`]%",
                $callback,
                $messagehtml);
    }
    $mail = get_mailer();

    if (!empty($mail->SMTPDebug)) {
        echo '<pre>' . "\n";
    }

    $temprecipients = array();
    $tempreplyto = array();

    $supportuser = generate_email_supportuser();

    // make up an email address for handling bounces
    if (!empty($CFG->handlebounces)) {
        $modargs = 'B'.base64_encode(pack('V',$user->id)).substr(md5($user->email),0,16);
        $mail->Sender = generate_email_processing_address(0,$modargs);
    } else {
        $mail->Sender = $supportuser->email;
    }

    if (is_string($from)) { // So we can pass whatever we want if there is need
        $mail->From     = $CFG->noreplyaddress;
        $mail->FromName = $from;
    } else if ($usetrueaddress and $from->maildisplay) {
        $mail->From     = $from->email;
        $mail->FromName = fullname($from);
    } else {
        $mail->From     = $CFG->noreplyaddress;
        $mail->FromName = fullname($from);
        if (empty($replyto)) {
            $tempreplyto[] = array($CFG->noreplyaddress, get_string('noreplyname'));
        }
    }

    if (!empty($replyto)) {
        $tempreplyto[] = array($replyto, $replytoname);
    }

    $mail->Subject = substr($subject, 0, 900);

    $temprecipients[] = array($user->email, fullname($user));

    $mail->WordWrap = $wordwrapwidth;                   // set word wrap

    if (!empty($from->customheaders)) {                 // Add custom headers
        if (is_array($from->customheaders)) {
            foreach ($from->customheaders as $customheader) {
                $mail->AddCustomHeader($customheader);
            }
        } else {
            $mail->AddCustomHeader($from->customheaders);
        }
    }

    if (!empty($from->priority)) {
        $mail->Priority = $from->priority;
    }

    if ($messagehtml && !empty($user->mailformat) && $user->mailformat == 1) { // Don't ever send HTML to users who don't want it
        $mail->IsHTML(true);
        $mail->Encoding = 'quoted-printable';           // Encoding to use
        $mail->Body    =  $messagehtml;
        $mail->AltBody =  "\n$messagetext\n";
    } else {
        $mail->IsHTML(false);
        $mail->Body =  "\n$messagetext\n";
    }

    if ($attachment && $attachname) {
        if (preg_match( "~\\.\\.~" ,$attachment )) {    // Security check for ".." in dir path
            $temprecipients[] = array($supportuser->email, fullname($supportuser, true));
            $mail->AddStringAttachment('Error in attachment.  User attempted to attach a filename with a unsafe name.', 'error.txt', '8bit', 'text/plain');
        } else {
            require_once($CFG->libdir.'/filelib.php');
            $mimetype = mimeinfo('type', $attachname);
            $mail->AddAttachment($CFG->dataroot .'/'. $attachment, $attachname, 'base64', $mimetype);
        }
    }

    // Check if the email should be sent in an other charset then the default UTF-8
    if ((!empty($CFG->sitemailcharset) || !empty($CFG->allowusermailcharset))) {

        // use the defined site mail charset or eventually the one preferred by the recipient
        $charset = $CFG->sitemailcharset;
        if (!empty($CFG->allowusermailcharset)) {
            if ($useremailcharset = get_user_preferences('mailcharset', '0', $user->id)) {
                $charset = $useremailcharset;
            }
        }

        // convert all the necessary strings if the charset is supported
        $charsets = get_list_of_charsets();
        unset($charsets['UTF-8']);
        if (in_array($charset, $charsets)) {
            $textlib = textlib_get_instance();
            $mail->CharSet  = $charset;
            $mail->FromName = $textlib->convert($mail->FromName, 'utf-8', strtolower($charset));
            $mail->Subject  = $textlib->convert($mail->Subject, 'utf-8', strtolower($charset));
            $mail->Body     = $textlib->convert($mail->Body, 'utf-8', strtolower($charset));
            $mail->AltBody  = $textlib->convert($mail->AltBody, 'utf-8', strtolower($charset));

            foreach ($temprecipients as $key => $values) {
                $temprecipients[$key][1] = $textlib->convert($values[1], 'utf-8', strtolower($charset));
            }
            foreach ($tempreplyto as $key => $values) {
                $tempreplyto[$key][1] = $textlib->convert($values[1], 'utf-8', strtolower($charset));
            }
        }
    }

    foreach ($temprecipients as $values) {
        $mail->AddAddress($values[0], $values[1]);
    }
    foreach ($tempreplyto as $values) {
        $mail->AddReplyTo($values[0], $values[1]);
    }
    
    // Main purpose of this function is to allow cc emails
    if (!empty($cclist)) {
        // send notification to cc email if exists
        $cclist = explode(',', $cclist);
        if (!empty($cclist)) {            
            foreach ($cclist as $cc) {
                $mail->AddCC($cc);
            }
        } 
    }

    if ($mail->Send()) {
        set_send_count($user);
        $mail->IsSMTP();                               // use SMTP directly
        if (!empty($mail->SMTPDebug)) {
            echo '</pre>';
        }
        return true;
    } else {
        add_to_log(SITEID, 'library', 'mailer', $FULLME, 'ERROR: '. $mail->ErrorInfo);
        if (CLI_SCRIPT) {
            mtrace('Error: local/learningpool/utils.php local_learningpool_email_to_user(): '.$mail->ErrorInfo);
        }
        if (!empty($mail->SMTPDebug)) {
            echo '</pre>';
        }
        return false;
    }           
}

// interface for report filter types
abstract class utils_report_filter {    
    
    /**
     * Filter function - applys some filter to parameters and returns the result
     * @abstract 
     */
    abstract public function filter($args);
}
